% !TeX encoding = UTF-8
% !TeX root = main.tex

\subsection{Relations between security definitions}
In the following we \sebastian{hopefully} establish relations between 
the security definitions from above.

\sebastian{These are conjectures. I will try to prove them:}
% \begin{lemma}
%     \label{lem:UCcorrectness}
%     Let $\pi$ be an OPRF that UC-realizes $\funcOPRF$. Then $\pi$ has correctness (cf. \Cref{def:simple-oprf}).
% \end{lemma}
% \sebastian{I don't know if correctness is implied by UC security. The ideal functionality has no notion of a key. And also not really of a function that is computed.
% One could define $f(x,\key)$ as the output of an interaction of an honest client and an honest server on input $x$ and the $\key$ is the key that the simulator outputs when the server is compromised. But even then $f$ is a different $f$ in every session. E.g., 2HashDH is not really a function of $x$ and $\key$ but of $x,\key,\sid$.}

\begin{lemma}
    \label{lem:UCinputpriv}
    Let $\pi$ be an OPRF that UC-realizes $\funcOPRF$. Then $\pi$ has input privacy against honest-but-curious servers (cf. \Cref{def:simple-oprf}).
\end{lemma}
\begin{proof}
    The proof strategy is to replace the real protocol transcript in $\ExpInputPrivOne$ by transcripts that are produced by the UC-simulator. If $\advA$ would change its output in the modified game then we can turn $\advA$ into a distinguishing environment for the UC-simulation. In the modified game, the transcripts $\tau_b$ and $\tau_{1-b}$ that $\advA$ sees are distributed identically and thus, they are independent of the bit $b$. Consequently, $\advA$ can guess correctly at most with probability $1/2$.
    
    Let $\Sim$ be the UC-simulator. We modify the game $\ExpInputPrivOne$ to obtain the modified game $\ExpInputPrivOne^\Sim$ as depicted in \cref{fig:input-privSimulated}.

    \begin{figure}
        \fbox{
        \begin{tabular}{l}
            \begin{tabular}{l}  
                \textbf{Experiment $\ExpInputPrivOne^\Sim$}\\
                \midrule
                Give input $(\Compromise,\sid)$ to $\Sim$ on behalf of $\Env$\\
                $\Sim$ responds with $\key\in\KeySpace$\\
                $b'\gets\AdvA^{\Trans(\cdot,\cdot),\RO(\cdot)}(pp,\key)$\\
                output $b'$
            \end{tabular}\\
            \\
            \begin{tabular}{l} 
                \textbf{Oracle $\Trans(x_0,x_1)$}\\
                \midrule
                Give input $(\Eval,\sid,\ssid,\User,\Server)$ and $(\Eval,\sid,\ssid',\User,\Server)$ to $\Sim$ on behalf of $\funcOPRF$\\
                Give input $(\SndrComplete,\sid,\ssid,\Server)$ and $(\SndrComplete,\sid,\ssid',\Server)$ to $\Sim$ on behalf of $\funcOPRF$\\
                $\Sim$ responds with $(\alpha,\beta)$ and $(\alpha',\beta')$\\
                Send permission to deliver all messages to $\Sim$ ob behalf of $\Env$\\
                $\Sim$ responds with  $(\RcvComplete,\sid,\ssid,\Server,i)$ and $(\RcvComplete,\sid,\ssid',\Server,i')$ to $\funcOPRF$\\
                If $i= i'$ and $x_0=x_1$, then choose $y\gets\OutputSpace$ and set $y'\coloneqq y$\\
                Else choose $y'\gets\OutputSpace$ and $y'\getsr\OutputSpace$\\
                $\tau \coloneqq(\alpha,\beta,y)$\\
                $\tau' \coloneqq(\alpha',\beta',y')$\\
                return $(\tau,\tau')$
            \end{tabular} \\ 
        \end{tabular}
        }
        \caption{The modified input-privacy experiment $\ExpInputPrivOne^\Sim$. All $\RO$ queries are also forwarded to $\Sim$. (Like, e.g., \cite{EC:JarKraXu18} but different than \cite{EPRINT:BDFH24}, we do not split the $\RcvComplete$ interface here. This is just syntactic.)}
        \label{fig:input-privSimulated}
    \end{figure}

    First note that if $\advA$'s output distribution would change between $\ExpInputPrivOne$ and $\ExpInputPrivOne^\Sim$ then one can construct an environment $\Env_\advA$ that can distinguish the real execution of the protocol from the ideal execution with simulator $\Sim$ and the ideal functionality $\funcOPRF$, which contradicts the UC-security of $\pi$. 
    
    \begin{itemize}
        \item $\Env_\advA$ sends $(\Compromise,\sid)$ to $\Sim$ and on a response $\key$ it runs $\advA$ as in $\ExpInputPrivOne$.
        \item Whenever $\advA$ makes a call to $\Trans(x_0,x_1)$ then $\Env_\advA$ gives input $(\Eval,\sid,\ssid,\User,\Server)$ and $(\Eval,\sid,\ssid',\User,\Server)$ to $\User$ and input $(\SndrComplete,\sid,\ssid,\Server)$ and $(\SndrComplete,\sid,\ssid',\Server)$ to $\Server$.
        Note that consequently, in the ideal world, $\funcOPRF$ gives the same input to $\Sim$ as in $\ExpInputPrivOne^\Sim$ and $\Sim$ computes $(\alpha,\beta)$ and $(\alpha,\beta)$ as in $\ExpInputPrivOne^\Sim$. 
        In the real world, $(\alpha,\beta)$ and $(\alpha',\beta')$ by $\User$ and $\Server$ executing the protocol code, as in $\ExpInputPrivOne$. 
        \item When $\advA$ makes a $\RO$ query, $\Env_advA$ forwards this to its own $\RO$ (i.e., the RO-functionality.)
        \item $\Env_\advA$ allows the delivery of all messages. 
        In the real world that means that the two honest parties will output $y$ and $y'$ exactly as in $\ExpInputPrivOne$. 
        To ensure that
        the honest parties in the ideal world also produce output, $\Sim$ will send messages $(\RcvComplete,\sid,\ssid,i)$ and $(\RcvComplete,\sid,\ssid',i')$ to $\funcOPRF$. 
        The functionality then samples the output values $y$ and $y'$ from the respective random table: $y\gets T_i[x_0]$ and $y'\gets T_{i'}[x_1]$. 
        In other words, if $i\neq i'$ then $y,y'$ are sampled independently. 
        If $i=i'$ but $x_0\neq x_1$ then the values are still sampled independently. 
        Only if both, $i=i'$ and $x_0=x_1$ both are set to the same value. This is exactly, what $\ExpInputPrivOne^\Sim$ does. 
        \item Finally, $\Env_\advA$ outputs what $\advA$ outputs.
    \end{itemize}
    Overall, in the real world, the view of $\advA$ is distributed as in $\ExpInputPrivOne$ and in the ideal world, the view of $\advA$ is distributed as in $\ExpInputPrivOne^\Sim$.

    Now, in $\ExpInputPrivOne^\Sim$, one can observer that $\tau$ and $\tau'$ are distributed the same.
    $x_0$ and $x_1$ are only used to check if $y$ and $y'$ have to be the same or independent. But in both cases their distribution does not depend on $b$.
    That means, $\advA$ has no advantage for winning this game.
\end{proof}

\begin{lemma}
    \label{lem:UCpseudorand}
    Let $\pi$ be an OPRF that UC-realizes $\funcOPRF$ and that has correctness \sebastian{Depends on the correctness result if we need to demand this separately.}. Then $\pi$ has pseudo-randomness (cf. \Cref{def:simple-oprf}).
\end{lemma}
\begin{proof}
    Assume, by way of contradiction, that there is a PPT adversary $\advA$ that has noticeable advantage in the $\ExpPseudoR$ game. Then, one can construct an environment $\Env_\advA$ that distinguishes the real UC-execution from the ideal execution with simulator $\SimUC$ and the ideal functionality
    $\funcOPRF$. (For this proof, we denote by $\Sim$ the simulator from $\ExpPseudoR$ and with $\SimUC$ the UC-simulator.)


    $\Env_\advA$ internally runs $\advA$.
    \begin{itemize}
        \item When $\advA$ sends a query $x$ to its $\Eval$ oracle, $\Env_\advA$ gives input $(\OfflineEval,sid,\ssid,x)$ to $\Server$. The $\Server$ returns $y$ and $\Env_\advA$ gives this as output of $\Eval(x)$ to $\advA$.
        \item When $\advA$ sends a query $\alpha$ to its $\BlindEvaluate$ oracle, then $\Env_\advA$ gives input $(\SndrComplete,\sid,\ssid)$ to $\Server$ and instructs the dummy adversary to give the input $\alpha$ to $\Server$ on behalf of user $\User$. The dummy adversary will report in response a message $\beta$ that was sent by $\Server$ to $\User$. Return this $\beta$ as output of the oracle.
        \item When $\advA$ sends a query $x$ to its $\Prim$ oracle, then $\Env_\advA$ forwards it to its own $\RO$, i.e., the ideal RO-functionality.
    \end{itemize}
    In the end, $\Env_\advA$ outputs what $\advA$ outputs.

    In the following, we argue that if $\Env_\advA$ is in the real-world execution of the UC-experiment, then $\Env_\advA$ perfectly simulates $\advA$'s view in $\ExpPseudoR^0$ and if $\Env_\advA$ is in the ideal-world execution of the UC-experiment, then $\Env_\advA$ perfectly simulates $\advA$'s view in $\ExpPseudoR^1$.

    \paragraph{$\Eval$ queries.} In the real world, when queried with $(\OfflineEval,\sid,\ssid,x)$ the server outputs $f(\key,x)$, where $f$ is the function that is computed by $\pi$ because $\pi$ has correctness. 
    \sebastian{Does $\pi$ really have to output this? Could it output for $\OfflineEval$ a different function than the one computed by the protocol?}
    In the ideal world, the output of $\Server$ is generated by $\funcOPRF$. The functionality sets the value to $T_\Server[x]$, where $T_\Server$ is the random table kept by $\funcOPRF$ for the honest server.
\end{proof}

\begin{corollary}
    \label{coro:UCfromGames}
   Let $\pi$ be an OPRF that UC-realizes $\funcOPRF$ and that additionally has correctness. Then $\pi$ is a secure OPRF according to \Cref{def:simple-oprf}. 
\end{corollary}
This is a direct consequence of \Cref{lem:UCpseudorand}, and \Cref{lem:UCinputpriv}.

\begin{lemma}
    \label{lem:GameInputPrivFromSim}
    Let $\pi$ have simulation-based input-privacy. Then $\pi$ has input-privacy against honest-but-curious servers.
\end{lemma}
\begin{proof}
    \sebastian{TODO}
\end{proof}

\begin{lemma}
    \label{lem:UCFLateExtractFromGames}
    Let $\pi$ be an OPRF satisfying correctness, pseudo-randomness,simulation-based input-privacy and weak key-collision resistance. Then $\pi$ UC-realizes $\FlateExtract$.
\end{lemma}
\begin{proof}
    \sebastian{TODO}
\end{proof}