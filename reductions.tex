% !TeX encoding = UTF-8
% !TeX root = main.tex

\begin{theorem}
 Let $\pi$ UC-realize $\funcOPRF$. Then $\pi$ has input blindness and pseudo-randomness as in \cref{def:simple-oprf}.
\end{theorem}
\begin{proof}
\paragraph{Input Privacy:}

\paragraph{Pseudo-randomness:}
Let $\advA$ be an adversary playing the input blindness game. $\advA$ has access to oracles $\Req$ and $\Fin$
that execute the ORPF like an honest client would do for two inputs $x_0$ and $x_1$ of $\advA$'s choice. 
We will first, replace these oracles by a simulated ones, using the UC simulator $\Spi$ for $\pi$. Then, the view of $\advA$ will be independent of the messages and thus, the success probability will be independent of the choice bit $b$.

First, consider the changed experiment $\widetilde\ExpInputBlind$
that works like $\ExpInputBlind$ except for how $\Req$ and $\Fin$
are implemented.
In this new experiment, the oracles $\Req$ and $\Fin$ will internally run $\Spi$ and interact with $\Spi$ as the ideal functionality $\funcOPRF$ and the UC-environment $\env$ would do.

$\widetilde\ExpInputBlind$ starts by choosing a fresh $\sid$ and giving input $(\Init,\sid,\Server)$ to $\Spi$ on behalf of the ideal functionality $\funcOPRF$. 
Next, when $\advA$ calls $\Req$, the input $x_0,x_1$ is ignored and instead $(\Eval,\sid,i,\User,\Server)$ is given to $\Spi$ on behalf of $\funcOPRF$, where $i$ is the counter like in the original $\Req$ oracle.
Because the real-world client would send a message $a$ now, $\Spi$ must also produce a message $a_{\Spi}$ now. Else, the simulation would be trivially distinguishable from the real world.
When $\Spi$ return this message to the oracle, then 

\end{proof}