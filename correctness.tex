% !TeX encoding = UTF-8
% !TeX root = main.tex

In this section, we elaborate on the fact that the ideal OPRF functionality $\funcOPRF$ that is usually used in the literature,
does not guarantee correctness as defined by \cref{EC:TCRSTW22}. 
This observation is very similar to the results from \cite{PKC:Roy22} for PAKE.

Concretely, we show that the following protocol UC-realize $\funcOPRF$:
\begin{itemize}
    \item On input $(\Eval,\sid,\ssid,\Server,x)$ the client chooses a random value $y$ and outputs $y$
    \item The server keeps an internal table $T$ that is initially empty. On every message $(\OfflineEval,\sid,\Server,x)$ from the environment the server chooses a uniformly random $y\getsr\OutputSpace$, sets $T[x]\coloneqq y$ and returns $y$ to $\Env$.
\end{itemize}
It is interesting to note here, that the functionality requires that the server internally holds a function $f$, that can be queried by the environment through the $\OfflineEval$ interface.
This function, however, is independent of the outputs of the client, even if all parties behave honestly. In particular, the client's output is \emph{not a function of $x$} as the same $x$ may lead to different random outputs.
There are two things to note about this function $f$:
\begin{itemize}
    \item The function is a different function everytime you run the protocol (because $\funcOPRF$ uses a different \enquote{honest table} $T_\sid$)
    \item The function will have exponentially big description and will not necessarily depend on a key, again because it's just some random function. (Technically, the definition of Tyagi et al. does not require the two things. A funtion $f(x)$ is in particular a function $f(\key,x)$ that just ignores the first argument. Also $f$ is not required to be efficiently computable. \sebastian{Still, feels odd}.)
\end{itemize}

The simulator for the protocol works as follows:
\begin{itemize}
    \item On a message $(\Eval,\sid,\ssid,\PartyP, \Server)$ the simulator chooses $i\getsr\mathcal{I}$ and sends $(\RcvComplete,\sid,\ssid,\PartyP,i)$ to $\funcOPRF$.
    % \item On $(\OfflineEval,\sid,\Server,x)$ messages 
    \item The simulator ignores all other messages.
\end{itemize}


% s seems to be more tricky than I thought. 
% First, I thought the trivial protocol, where the client always outputs a random value could be simulated.
% That is \emph{not} the case. The reason is, that the honest server is also allowed
% to send $\OfflineEval$ queries to $\funcOPRF$ (as long as $i=\Server)$.
% That means, $\funcOPRF$ implies at least that the protocol computes a function in $x$, because
% the output of $\OfflineEval$ and the output of the client interacting with that server must be the same.
